### 자바의 불편한 점

- 자바 = 객체지향프로그래밍
- 객체 관리(생성 위치, 시점 등과 의존성)에 많은 에너지 쓰임
- 이를 스프링이 도와줌.

### 스프링의 주요 원리

#### IoC - Inversion of Control

제어의 역전
여기서 역전이란? 상황이 전반대가 되다.
즉, 프로그램(객체)의 흐름을 제어하는 것이 정반대(개발자와 스프링)로 뒤집힌다.

- 객체에 대한 제어권을 반대로 뒤집는다.
- 객체의 생명주기를 개발자가 제어한다 --제어의 역전--> 제어권을 개발자가 안 갖고 스프링이 가진다.

`객체가 흩뿌려진 걸 효과적으로 관리하기 위해 스프링은 어떤 선택을 했을까?` `내 생각: 각 객체마다 꼬리표를 부탁해서 라벨링한 뒤 한번에 관리?`

#### 컨테이너

- 스프링의 객체 관리 방법: 객체를 모아두는 공간 = !!컨테이너!! 를 사용

#### 스프링 빈: 스프링이 컴테이너에 담아두고 관리하는 객체

#### DI: 의존성 주입

- 의존성 = 사용성 = 사용할/ 사용하는 것 = 객체

* 주입 = 개발자는 주입 받는 입장(스프링님 객체 주실 수 있을까요?), 스프링은 해주는 입장(스프링은 객체담당)
  그러므로 의존성 주입은 제어의 역전으로 인해 제어권을 가져온 스프링이 객체를 주고, 개발자는 사용하는 것.

- 객체 사용 = 객체 생성, 메소드, 필드 호출, 접근

> IoC를 구현하기 위해 DI가 필요하다.

### 실습

#### 주제

- 상품 조회, 등록 API 프로젝트

`어떤 클래스, 객체를 만들어야할까?`

- Sprint web Dependencies에서 제공하는 Spring MVC를 활용하면 된다.

#### 클래스 구조(=역할 부여)/ Spring MVC

- V : view = 화면 -> front로 넘기자
- C : controller -> view(사용자)와 모델의 중간 매개체
- M: model -> 데이터를 이용해 연산, 로직
  - 연산을 위해선 DB 소통 필요, 로직 작성도 필요 -> 쪼개기 -> DB 소통 = repogitory/ 로직 = seviece [상세히 분리함 = 유지보수성 증가]
    화면 - 컨트롤러 - 모델: 요청과 응답의 교류. 컨트롤러부터 설계 시작

#### 어노테이션

스프링에게 객체 부탁하는 언어 문법

- 자바 개념!
- 어노테이션 In 자바: 알려줌
  1. @Override = 컴파일러에게 오버라이드 하고싶다고, 문법 확인해달라고 요청(즉, 일은 컴파일러)
  2. 빌드 도구에게 @Getter
  3. 프레임워크(스프링 등) @스프링아 이 클래스 스프링빈으로 관리해줘

#### IoC의 시작

스프링에게 객체 부탁하는 두가지 방법
@Component

- 클래스 위에 달아서 사용
  = 이 클래스를 스프링 빈으로 등록해줘 = 네가 관리하는 객체 공간에 넣어줘 = 이 클래스를 객체로 생성해서 스프링 빈으로 등록해줘
  @ Configuratio+ @Bean
- 나중에 공부
